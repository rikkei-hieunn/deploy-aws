<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>References: go/types.Func</title>
<link href="../../css/light-v0.4.9.css" rel="stylesheet">
<script src="../../jvs/golds-v0.4.9.js"></script>
<body onload="onPageLoad()"><div>

<pre><code><span style="font-size:x-large;">type <b><a href="../../pkg/go/types.html">go/types</a>.<a href="../../src/go/types/object.go.html#line-320">Func</a></b></span>

<span class="title">106 uses</span>

	go/types (current package)
		<a href="../../src/go/types/builtins.go.html#line-671">builtins.go#L671</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/call.go.html#line-509">call.go#L509</a>: 			case *<b>Func</b>:
		<a href="../../src/go/types/call.go.html#line-589" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-589">#L589</a>: 	if m, _ := obj.(*<b>Func</b>); m != nil {
		<a href="../../src/go/types/call.go.html#line-595" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-595">#L595</a>: 		m, _ := obj.(*<b>Func</b>)
		<a href="../../src/go/types/call.go.html#line-653" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-653">#L653</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/check.go.html#line-132">check.go#L132</a>: 	methods  map[*TypeName][]*<b>Func</b> // maps package scope type names to associated non-blank (non-interface) methods
		<a href="../../src/go/types/decl.go.html#line-151">decl.go#L151</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/decl.go.html#line-198" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-198">#L198</a>: 	case *<b>Func</b>:
		<a href="../../src/go/types/decl.go.html#line-259" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-259">#L259</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/decl.go.html#line-766" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-766">#L766</a>: 					_ = alt.(*<b>Func</b>)
		<a href="../../src/go/types/decl.go.html#line-778" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-778">#L778</a>: func (check *Checker) funcDecl(obj *<b>Func</b>, decl *declInfo) {
		<a href="../../src/go/types/initorder.go.html#line-233">initorder.go#L233</a>: 		if _, ok := n.obj.(*<b>Func</b>); ok {
		<a href="../../src/go/types/interface.go.html#line-19">interface.go#L19</a>: 	methods   []*<b>Func</b>      // ordered list of explicitly declared methods
		<a href="../../src/go/types/interface.go.html#line-39" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-39">#L39</a>: func NewInterface(methods []*<b>Func</b>, embeddeds []*Named) *Interface {
		<a href="../../src/go/types/interface.go.html#line-53" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-53">#L53</a>: func NewInterfaceType(methods []*<b>Func</b>, embeddeds []Type) *Interface {
		<a href="../../src/go/types/interface.go.html#line-98" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-98">#L98</a>: func (t *Interface) ExplicitMethod(i int) *<b>Func</b> { return t.methods[i] }
		<a href="../../src/go/types/interface.go.html#line-117" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-117">#L117</a>: func (t *Interface) Method(i int) *<b>Func</b> { return t.typeSet().Method(i) }
		<a href="../../src/go/types/lookup.go.html#line-59">lookup.go#L59</a>: 			if _, ok := obj.(*<b>Func</b>); ok {
		<a href="../../src/go/types/lookup.go.html#line-203" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-203">#L203</a>: 			if f, _ := obj.(*<b>Func</b>); f != nil {
		<a href="../../src/go/types/lookup.go.html#line-294" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-294">#L294</a>: func MissingMethod(V Type, T *Interface, static bool) (method *<b>Func</b>, wrongType bool) {
		<a href="../../src/go/types/lookup.go.html#line-308" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-308">#L308</a>: func (check *Checker) missingMethod(V Type, T *Interface, static bool) (method, alt *<b>Func</b>) {
		<a href="../../src/go/types/lookup.go.html#line-350" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-350">#L350</a>: 		f, _ := obj.(*<b>Func</b>)
		<a href="../../src/go/types/lookup.go.html#line-374" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-374">#L374</a>: func (check *Checker) missingMethodReason(V, T Type, m, alt *<b>Func</b>) string {
		<a href="../../src/go/types/lookup.go.html#line-422" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-422">#L422</a>: func (check *Checker) funcString(f *<b>Func</b>) string {
		<a href="../../src/go/types/lookup.go.html#line-438" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-438">#L438</a>: func (check *Checker) assertableTo(V *Interface, T Type) (method, wrongType *<b>Func</b>) {
		<a href="../../src/go/types/lookup.go.html#line-511" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-511">#L511</a>: func lookupMethod(methods []*<b>Func</b>, pkg *Package, name string, foldCase bool) (int, *<b>Func</b>) {
		<a href="../../src/go/types/methodlist.go.html#line-12">methodlist.go#L12</a>: 	methods []*<b>Func</b>
		<a href="../../src/go/types/methodlist.go.html#line-21" class="path-duplicate">methodlist.go</a><a href="../../src/go/types/methodlist.go.html#line-21">#L21</a>: func newMethodList(methods []*<b>Func</b>) *methodList {
		<a href="../../src/go/types/methodlist.go.html#line-30" class="path-duplicate">methodlist.go</a><a href="../../src/go/types/methodlist.go.html#line-30">#L30</a>: 		methods: make([]*<b>Func</b>, length),
		<a href="../../src/go/types/methodlist.go.html#line-42" class="path-duplicate">methodlist.go</a><a href="../../src/go/types/methodlist.go.html#line-42">#L42</a>: func (l *methodList) Add(m *<b>Func</b>) {
		<a href="../../src/go/types/methodlist.go.html#line-52" class="path-duplicate">methodlist.go</a><a href="../../src/go/types/methodlist.go.html#line-52">#L52</a>: func (l *methodList) Lookup(pkg *Package, name string, foldCase bool) (int, *<b>Func</b>) {
		<a href="../../src/go/types/methodlist.go.html#line-70" class="path-duplicate">methodlist.go</a><a href="../../src/go/types/methodlist.go.html#line-70">#L70</a>: func (l *methodList) At(i int, resolve func() *<b>Func</b>) *<b>Func</b> {
		<a href="../../src/go/types/methodset.go.html#line-210">methodset.go#L210</a>: func (s methodSet) add(list []*<b>Func</b>, index []int, indirect bool, multiples bool) methodSet {
		<a href="../../src/go/types/methodset.go.html#line-220" class="path-duplicate">methodset.go</a><a href="../../src/go/types/methodset.go.html#line-220">#L220</a>: func (s methodSet) addOne(f *<b>Func</b>, index []int, indirect bool, multiples bool) methodSet {
		<a href="../../src/go/types/named.go.html#line-37">named.go#L37</a>: func NewNamed(obj *TypeName, underlying Type, methods []*<b>Func</b>) *Named {
		<a href="../../src/go/types/named.go.html#line-135" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-135">#L135</a>: func (t *Named) Method(i int) *<b>Func</b> {
		<a href="../../src/go/types/named.go.html#line-137" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-137">#L137</a>: 	return t.methods.At(i, func() *<b>Func</b> {
		<a href="../../src/go/types/named.go.html#line-143" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-143">#L143</a>: func (t *Named) instantiateMethod(i int) *<b>Func</b> {
		<a href="../../src/go/types/named.go.html#line-217" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-217">#L217</a>: func (t *Named) AddMethod(m *<b>Func</b>) {
		<a href="../../src/go/types/named.go.html#line-326" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-326">#L326</a>: func (n *Named) lookupMethod(pkg *Package, name string, foldCase bool) (int, *<b>Func</b>) {
		<a href="../../src/go/types/object.go.html#line-235">object.go#L235</a>: func _NewTypeNameLazy(pos token.Pos, pkg *Package, name string, load func(named *Named) (tparams []*TypeParam, underlying Type, methods []*<b>Func</b>)) *TypeName {
		<a href="../../src/go/types/object.go.html#line-320" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-320">#L320</a>: type <b>Func</b> struct {
		<a href="../../src/go/types/object.go.html#line-327" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-327">#L327</a>: func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *<b>Func</b> {
		<a href="../../src/go/types/object.go.html#line-333" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-333">#L333</a>: 	return &amp;<b>Func</b>{object{nil, pos, pkg, name, typ, 0, colorFor(typ), token.NoPos}, false}
		<a href="../../src/go/types/object.go.html#line-338" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-338">#L338</a>: func (obj *<b>Func</b>) FullName() string {
		<a href="../../src/go/types/object.go.html#line-347" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-347">#L347</a>: func (obj *<b>Func</b>) Scope() *Scope { return obj.typ.(*Signature).scope }
		<a href="../../src/go/types/object.go.html#line-350" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-350">#L350</a>: func (obj *<b>Func</b>) hasPtrRecv() bool {
		<a href="../../src/go/types/object.go.html#line-368" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-368">#L368</a>: func (*<b>Func</b>) isDependency() {} // a function may be a dependency of an initialization expression
		<a href="../../src/go/types/object.go.html#line-427" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-427">#L427</a>: 	case *<b>Func</b>:
		<a href="../../src/go/types/object.go.html#line-525" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-525">#L525</a>: func (obj *<b>Func</b>) String() string     { return ObjectString(obj, nil) }
		<a href="../../src/go/types/object.go.html#line-530" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-530">#L530</a>: func writeFuncName(buf *bytes.Buffer, f *<b>Func</b>, qf Qualifier) {
		<a href="../../src/go/types/resolver.go.html#line-225">resolver.go#L225</a>: 		obj  *<b>Func</b>      // method
		<a href="../../src/go/types/resolver.go.html#line-480" class="path-duplicate">resolver.go</a><a href="../../src/go/types/resolver.go.html#line-480">#L480</a>: 	check.methods = make(map[*TypeName][]*<b>Func</b>)
		<a href="../../src/go/types/selection.go.html#line-65">selection.go#L65</a>: 		sig := *s.obj.(*<b>Func</b>).typ.(*Signature)
		<a href="../../src/go/types/selection.go.html#line-76" class="path-duplicate">selection.go</a><a href="../../src/go/types/selection.go.html#line-76">#L76</a>: 		sig := *s.obj.(*<b>Func</b>).typ.(*Signature)
		<a href="../../src/go/types/subst.go.html#line-332">subst.go#L332</a>: func (subst *subster) func_(f *<b>Func</b>) *<b>Func</b> {
		<a href="../../src/go/types/subst.go.html#line-343" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-343">#L343</a>: func (subst *subster) funcList(in []*<b>Func</b>) (out []*<b>Func</b>, copied bool) {
		<a href="../../src/go/types/subst.go.html#line-350" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-350">#L350</a>: 				new := make([]*<b>Func</b>, len(in))
		<a href="../../src/go/types/subst.go.html#line-403" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-403">#L403</a>: func replaceRecvType(in []*<b>Func</b>, old, new Type) (out []*<b>Func</b>, copied bool) {
		<a href="../../src/go/types/subst.go.html#line-412" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-412">#L412</a>: 				out = make([]*<b>Func</b>, len(in))
		<a href="../../src/go/types/typeset.go.html#line-27">typeset.go#L27</a>: 	methods    []*<b>Func</b>  // all methods of the interface; sorted by unique ID
		<a href="../../src/go/types/typeset.go.html#line-56" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-56">#L56</a>: func (s *_TypeSet) Method(i int) *<b>Func</b> { return s.methods[i] }
		<a href="../../src/go/types/typeset.go.html#line-59" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-59">#L59</a>: func (s *_TypeSet) LookupMethod(pkg *Package, name string, foldCase bool) (int, *<b>Func</b>) {
		<a href="../../src/go/types/typeset.go.html#line-218" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-218">#L218</a>: 	var todo []*<b>Func</b>
		<a href="../../src/go/types/typeset.go.html#line-220" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-220">#L220</a>: 	var allMethods []*<b>Func</b>
		<a href="../../src/go/types/typeset.go.html#line-221" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-221">#L221</a>: 	mpos := make(map[*<b>Func</b>]token.Pos) // method specification or method embedding position, for good error messages
		<a href="../../src/go/types/typeset.go.html#line-222" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-222">#L222</a>: 	addMethod := func(pos token.Pos, m *<b>Func</b>, explicit bool) {
		<a href="../../src/go/types/typeset.go.html#line-233" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-233">#L233</a>: 			check.errorf(atPos(mpos[other.(*<b>Func</b>)]), _DuplicateDecl, "\tother declaration of %s", m.name) // secondary error, \t indented
		<a href="../../src/go/types/typeset.go.html#line-242" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-242">#L242</a>: 				todo = append(todo, m, other.(*<b>Func</b>))
		<a href="../../src/go/types/typeset.go.html#line-249" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-249">#L249</a>: 					check.errorf(atPos(mpos[other.(*<b>Func</b>)]), _DuplicateDecl, "\tother declaration of %s", m.name) // secondary error, \t indented
		<a href="../../src/go/types/typeset.go.html#line-366" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-366">#L366</a>: func sortMethods(list []*<b>Func</b>) {
		<a href="../../src/go/types/typeset.go.html#line-370" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-370">#L370</a>: func assertSortedMethods(list []*<b>Func</b>) {
		<a href="../../src/go/types/typeset.go.html#line-380" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-380">#L380</a>: type byUniqueMethodName []*<b>Func</b>
		<a href="../../src/go/types/typexpr.go.html#line-118">typexpr.go#L118</a>: 	case *<b>Func</b>:
		<a href="../../src/go/types/universe.go.html#line-101">universe.go#L101</a>: 		ityp := &amp;Interface{obj: obj, methods: []*<b>Func</b>{err}, complete: true}

	<a href="../../pkg/golang.org/x/exp/apidiff.html">golang.org/x/exp/apidiff</a>
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-132">apidiff.go#L132</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-134" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-134">#L134</a>: 		case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-178" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-178">#L178</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-127">compatibility.go#L127</a>: func unexportedMethod(t *types.Interface) *types.<b>Func</b> {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-259">correspondence.go#L259</a>: func (d *differ) sortedMethods(iface *types.Interface) []*types.<b>Func</b> {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-260" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-260">#L260</a>: 	ms := make([]*types.<b>Func</b>, iface.NumMethods())
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-268" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-268">#L268</a>: func (d *differ) methodID(m *types.<b>Func</b>) string {
		<a href="../../src/golang.org/x/exp/apidiff/messageset.go.html#line-58">messageset.go#L58</a>: 	if f, ok := obj.(*types.<b>Func</b>); ok {

	<a href="../../pkg/golang.org/x/tools/internal/gcimporter.html">golang.org/x/tools/internal/gcimporter</a>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-227">bexport.go#L227</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-389" class="path-duplicate">bexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-389">#L389</a>: 	var methods []*types.<b>Func</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-425" class="path-duplicate">bexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-425">#L425</a>: type methodsByName []*types.<b>Func</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-476" class="path-duplicate">bexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-476">#L476</a>: func (p *exporter) method(m *types.<b>Func</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-234">bimport.go#L234</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-644" class="path-duplicate">bimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-644">#L644</a>: func (p *importer) methodList(parent *types.Package, baseType *types.Named) (methods []*types.<b>Func</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-646" class="path-duplicate">bimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-646">#L646</a>: 		methods = make([]*types.<b>Func</b>, n)
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-654" class="path-duplicate">bimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-654">#L654</a>: func (p *importer) method(parent *types.Package, baseType *types.Named) *types.<b>Func</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-774">gcimporter.go#L774</a>: 	var methods []*types.<b>Func</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-346">iexport.go#L346</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-757">iimport.go#L757</a>: 		methods := make([]*types.<b>Func</b>, r.uint64())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/newInterface11.go^10e54.html#line-12">newInterface11.go#L12</a>: func newInterface(methods []*types.<b>Func</b>, embeddeds []types.Type) *types.Interface {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-416">ureader_yes.go#L416</a>: 	methods := make([]*types.<b>Func</b>, r.Len())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-578" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-578">#L578</a>: 					methods := make([]*types.<b>Func</b>, iface.NumExplicitMethods())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-695" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-695">#L695</a>: func (r *reader) method() *types.<b>Func</b> {

	<a href="../../pkg/golang.org/x/tools/internal/typeparams.html">golang.org/x/tools/internal/typeparams</a>
		<a href="../../src/golang.org/x/tools/internal/typeparams/common.go.html#line-87">common.go#L87</a>: func OriginMethod(fn *types.<b>Func</b>) *types.<b>Func</b> {
		<a href="../../src/golang.org/x/tools/internal/typeparams/common.go.html#line-109" class="path-duplicate">common.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/common.go.html#line-109">#L109</a>: 	return gfn.(*types.<b>Func</b>)
</code></pre><pre id="footer">
The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.4.9</i>. (GOOS=linux GOARCH=amd64)</pre>