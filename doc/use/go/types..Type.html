<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>References: go/types.Type</title>
<link href="../../css/light-v0.4.9.css" rel="stylesheet">
<script src="../../jvs/golds-v0.4.9.js"></script>
<body onload="onPageLoad()"><div>

<pre><code><span style="font-size:x-large;">type <b><a href="../../pkg/go/types.html">go/types</a>.<a href="../../src/go/types/type.go.html#line-9">Type</a></b></span>

<span class="title">463 uses</span>

	go/types (current package)
		<a href="../../src/go/types/api.go.html#line-286">api.go#L286</a>: func (info *Info) TypeOf(e ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/api.go.html#line-317" class="path-duplicate">api.go</a><a href="../../src/go/types/api.go.html#line-317">#L317</a>: 	Type  <b>Type</b>
		<a href="../../src/go/types/api.go.html#line-379" class="path-duplicate">api.go</a><a href="../../src/go/types/api.go.html#line-379">#L379</a>: 	Type     <b>Type</b>
		<a href="../../src/go/types/api.go.html#line-425" class="path-duplicate">api.go</a><a href="../../src/go/types/api.go.html#line-425">#L425</a>: func AssertableTo(V *Interface, T <b>Type</b>) bool {
		<a href="../../src/go/types/api.go.html#line-439" class="path-duplicate">api.go</a><a href="../../src/go/types/api.go.html#line-439">#L439</a>: func AssignableTo(V, T <b>Type</b>) bool {
		<a href="../../src/go/types/api.go.html#line-450" class="path-duplicate">api.go</a><a href="../../src/go/types/api.go.html#line-450">#L450</a>: func ConvertibleTo(V, T <b>Type</b>) bool {
		<a href="../../src/go/types/api.go.html#line-459" class="path-duplicate">api.go</a><a href="../../src/go/types/api.go.html#line-459">#L459</a>: func Implements(V <b>Type</b>, T *Interface) bool {
		<a href="../../src/go/types/api.go.html#line-474" class="path-duplicate">api.go</a><a href="../../src/go/types/api.go.html#line-474">#L474</a>: func Identical(x, y <b>Type</b>) bool {
		<a href="../../src/go/types/api.go.html#line-480" class="path-duplicate">api.go</a><a href="../../src/go/types/api.go.html#line-480">#L480</a>: func IdenticalIgnoreTags(x, y <b>Type</b>) bool {
		<a href="../../src/go/types/array.go.html#line-10">array.go#L10</a>: 	elem <b>Type</b>
		<a href="../../src/go/types/array.go.html#line-15" class="path-duplicate">array.go</a><a href="../../src/go/types/array.go.html#line-15">#L15</a>: func NewArray(elem <b>Type</b>, len int64) *Array { return &amp;Array{len: len, elem: elem} }
		<a href="../../src/go/types/array.go.html#line-22" class="path-duplicate">array.go</a><a href="../../src/go/types/array.go.html#line-22">#L22</a>: func (a *Array) Elem() <b>Type</b> { return a.elem }
		<a href="../../src/go/types/array.go.html#line-24" class="path-duplicate">array.go</a><a href="../../src/go/types/array.go.html#line-24">#L24</a>: func (t *Array) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/assignments.go.html#line-20">assignments.go#L20</a>: func (check *Checker) assignment(x *operand, T <b>Type</b>, context string) {
		<a href="../../src/go/types/assignments.go.html#line-136" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-136">#L136</a>: func (check *Checker) initVar(lhs *Var, x *operand, context string) <b>Type</b> {
		<a href="../../src/go/types/assignments.go.html#line-167" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-167">#L167</a>: func (check *Checker) assignVar(lhs ast.Expr, x *operand) <b>Type</b> {
		<a href="../../src/go/types/assignments.go.html#line-242" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-242">#L242</a>: func operandTypes(list []*operand) (res []<b>Type</b>) {
		<a href="../../src/go/types/assignments.go.html#line-250" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-250">#L250</a>: func varTypes(list []*Var) (res []<b>Type</b>) {
		<a href="../../src/go/types/assignments.go.html#line-261" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-261">#L261</a>: func (check *Checker) typesSummary(list []<b>Type</b>, variadic bool) string {
		<a href="../../src/go/types/assignments.go.html#line-363" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-363">#L363</a>: 		var a [2]<b>Type</b>
		<a href="../../src/go/types/assignments.go.html#line-396" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-396">#L396</a>: 		var a [2]<b>Type</b>
		<a href="../../src/go/types/basic.go.html#line-81">basic.go#L81</a>: func (t *Basic) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/builtins.go.html#line-85">builtins.go#L85</a>: 		var T <b>Type</b>
		<a href="../../src/go/types/builtins.go.html#line-199" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-199">#L199</a>: 			if t.typeSet().underIs(func(t <b>Type</b>) bool {
		<a href="../../src/go/types/builtins.go.html#line-238" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-238">#L238</a>: 		if !underIs(x.typ, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/builtins.go.html#line-318" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-318">#L318</a>: 		f := func(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/builtins.go.html#line-387" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-387">#L387</a>: 		var key <b>Type</b>
		<a href="../../src/go/types/builtins.go.html#line-388" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-388">#L388</a>: 		if !underIs(map_, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/builtins.go.html#line-446" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-446">#L446</a>: 		f := func(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/builtins.go.html#line-515" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-515">#L515</a>: 		types := []<b>Type</b>{T}
		<a href="../../src/go/types/builtins.go.html#line-576" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-576">#L576</a>: 		var params []<b>Type</b>
		<a href="../../src/go/types/builtins.go.html#line-578" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-578">#L578</a>: 			params = make([]<b>Type</b>, nargs)
		<a href="../../src/go/types/builtins.go.html#line-802" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-802">#L802</a>: func hasVarSize(t <b>Type</b>) bool {
		<a href="../../src/go/types/builtins.go.html#line-827" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-827">#L827</a>: func (check *Checker) applyTypeFunc(f func(<b>Type</b>) <b>Type</b>, x *operand, id builtinId) <b>Type</b> {
		<a href="../../src/go/types/builtins.go.html#line-866" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-866">#L866</a>: 		ptyp := check.newTypeParam(tpar, NewInterfaceType(nil, []<b>Type</b>{NewUnion(terms)})) // assigns type to tpar as a side-effect
		<a href="../../src/go/types/builtins.go.html#line-877" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-877">#L877</a>: func makeSig(res <b>Type</b>, args ...<b>Type</b>) *Signature {
		<a href="../../src/go/types/builtins.go.html#line-893" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-893">#L893</a>: func arrayPtrDeref(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/call.go.html#line-63">call.go#L63</a>: func (check *Checker) instantiateSignature(pos token.Pos, typ *Signature, targs []<b>Type</b>, xlist []ast.Expr) (res *Signature) {
		<a href="../../src/go/types/call.go.html#line-184" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-184">#L184</a>: 	var targs []<b>Type</b>
		<a href="../../src/go/types/call.go.html#line-288" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-288">#L288</a>: func (check *Checker) arguments(call *ast.CallExpr, sig *Signature, targs []<b>Type</b>, args []*operand, xlist []ast.Expr) (rsig *Signature) {
		<a href="../../src/go/types/chan.go.html#line-10">chan.go#L10</a>: 	elem <b>Type</b>
		<a href="../../src/go/types/chan.go.html#line-24" class="path-duplicate">chan.go</a><a href="../../src/go/types/chan.go.html#line-24">#L24</a>: func NewChan(dir ChanDir, elem <b>Type</b>) *Chan {
		<a href="../../src/go/types/chan.go.html#line-32" class="path-duplicate">chan.go</a><a href="../../src/go/types/chan.go.html#line-32">#L32</a>: func (c *Chan) Elem() <b>Type</b> { return c.elem }
		<a href="../../src/go/types/chan.go.html#line-34" class="path-duplicate">chan.go</a><a href="../../src/go/types/chan.go.html#line-34">#L34</a>: func (t *Chan) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/check.go.html#line-169">check.go#L169</a>: func (check *Checker) validAlias(alias *TypeName, typ <b>Type</b>) {
		<a href="../../src/go/types/check.go.html#line-406" class="path-duplicate">check.go</a><a href="../../src/go/types/check.go.html#line-406">#L406</a>: 	var typ <b>Type</b>
		<a href="../../src/go/types/check.go.html#line-444" class="path-duplicate">check.go</a><a href="../../src/go/types/check.go.html#line-444">#L444</a>: func (check *Checker) recordTypeAndValue(x ast.Expr, mode operandMode, typ <b>Type</b>, val constant.Value) {
		<a href="../../src/go/types/check.go.html#line-479" class="path-duplicate">check.go</a><a href="../../src/go/types/check.go.html#line-479">#L479</a>: func (check *Checker) recordCommaOkTypes(x ast.Expr, a [2]<b>Type</b>) {
		<a href="../../src/go/types/check.go.html#line-511" class="path-duplicate">check.go</a><a href="../../src/go/types/check.go.html#line-511">#L511</a>: func (check *Checker) recordInstance(expr ast.Expr, targs []<b>Type</b>, typ <b>Type</b>) {
		<a href="../../src/go/types/check.go.html#line-562" class="path-duplicate">check.go</a><a href="../../src/go/types/check.go.html#line-562">#L562</a>: func (check *Checker) recordSelection(x *ast.SelectorExpr, kind SelectionKind, recv <b>Type</b>, obj Object, index []int, indirect bool) {
		<a href="../../src/go/types/context.go.html#line-25">context.go#L25</a>: 	originIDs map[<b>Type</b>]int           // origin type -&gt; unique ID
		<a href="../../src/go/types/context.go.html#line-29" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-29">#L29</a>: 	orig     <b>Type</b>
		<a href="../../src/go/types/context.go.html#line-30" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-30">#L30</a>: 	targs    []<b>Type</b>
		<a href="../../src/go/types/context.go.html#line-31" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-31">#L31</a>: 	instance <b>Type</b> // = orig[targs]
		<a href="../../src/go/types/context.go.html#line-38" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-38">#L38</a>: 		originIDs: make(map[<b>Type</b>]int),
		<a href="../../src/go/types/context.go.html#line-45" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-45">#L45</a>: func (ctxt *Context) instanceHash(orig <b>Type</b>, targs []<b>Type</b>) string {
		<a href="../../src/go/types/context.go.html#line-67" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-67">#L67</a>: func (ctxt *Context) lookup(h string, orig <b>Type</b>, targs []<b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/context.go.html#line-88" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-88">#L88</a>: func (ctxt *Context) update(h string, orig <b>Type</b>, targs []<b>Type</b>, inst <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/context.go.html#line-114" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-114">#L114</a>: func (ctxt *Context) getID(t <b>Type</b>) int {
		<a href="../../src/go/types/conversions.go.html#line-16">conversions.go#L16</a>: func (check *Checker) conversion(x *operand, T <b>Type</b>) {
		<a href="../../src/go/types/conversions.go.html#line-19" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-19">#L19</a>: 	constConvertibleTo := func(T <b>Type</b>, val *constant.Value) bool {
		<a href="../../src/go/types/conversions.go.html#line-50" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-50">#L50</a>: 		ok = T.(*TypeParam).underIs(func(u <b>Type</b>) bool {
		<a href="../../src/go/types/conversions.go.html#line-129" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-129">#L129</a>: func (x *operand) convertibleTo(check *Checker, T <b>Type</b>, cause *string) bool {
		<a href="../../src/go/types/conversions.go.html#line-269" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-269">#L269</a>: func isUintptr(typ <b>Type</b>) bool {
		<a href="../../src/go/types/conversions.go.html#line-274" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-274">#L274</a>: func isUnsafePointer(typ <b>Type</b>) bool {
		<a href="../../src/go/types/conversions.go.html#line-279" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-279">#L279</a>: func isPointer(typ <b>Type</b>) bool {
		<a href="../../src/go/types/conversions.go.html#line-284" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-284">#L284</a>: func isBytesOrRunes(typ <b>Type</b>) bool {
		<a href="../../src/go/types/decl.go.html#line-524">decl.go#L524</a>: func (check *Checker) isImportedConstraint(typ <b>Type</b>) bool {
		<a href="../../src/go/types/decl.go.html#line-536" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-536">#L536</a>: 	var rhs <b>Type</b>
		<a href="../../src/go/types/decl.go.html#line-628" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-628">#L628</a>: 		var bound <b>Type</b>
		<a href="../../src/go/types/decl.go.html#line-651" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-651">#L651</a>: func (check *Checker) bound(x ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/errors.go.html#line-100">errors.go#L100</a>: 		case <b>Type</b>:
		<a href="../../src/go/types/errors.go.html#line-102" class="path-duplicate">errors.go</a><a href="../../src/go/types/errors.go.html#line-102">#L102</a>: 		case []<b>Type</b>:
		<a href="../../src/go/types/expr.go.html#line-60">expr.go#L60</a>: type opPredicates map[token.Token]func(<b>Type</b>) bool
		<a href="../../src/go/types/expr.go.html#line-149" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-149">#L149</a>: func underIs(typ <b>Type</b>, f func(<b>Type</b>) bool) bool {
		<a href="../../src/go/types/expr.go.html#line-455" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-455">#L455</a>: func (check *Checker) invalidConversion(code errorCode, x *operand, target <b>Type</b>) {
		<a href="../../src/go/types/expr.go.html#line-475" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-475">#L475</a>: func (check *Checker) updateExprType(x ast.Expr, typ <b>Type</b>, final bool) {
		<a href="../../src/go/types/expr.go.html#line-479" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-479">#L479</a>: func (check *Checker) updateExprType0(parent, x ast.Expr, typ <b>Type</b>, final bool) {
		<a href="../../src/go/types/expr.go.html#line-605" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-605">#L605</a>: func (check *Checker) convertUntyped(x *operand, target <b>Type</b>) {
		<a href="../../src/go/types/expr.go.html#line-632" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-632">#L632</a>: func (check *Checker) implicitTypeAndValue(x *operand, target <b>Type</b>) (<b>Type</b>, constant.Value, errorCode) {
		<a href="../../src/go/types/expr.go.html#line-692" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-692">#L692</a>: 			if !u.typeSet().underIs(func(u <b>Type</b>) bool {
		<a href="../../src/go/types/expr.go.html#line-855" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-855">#L855</a>: func (check *Checker) incomparableCause(typ <b>Type</b>) string {
		<a href="../../src/go/types/expr.go.html#line-869" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-869">#L869</a>: func (check *Checker) kindString(typ <b>Type</b>) string {
		<a href="../../src/go/types/expr.go.html#line-1198" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1198">#L1198</a>: func (check *Checker) rawExpr(x *operand, e ast.Expr, hint <b>Type</b>, allowGeneric bool) exprKind {
		<a href="../../src/go/types/expr.go.html#line-1246" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1246">#L1246</a>: func (check *Checker) exprInternal(x *operand, e ast.Expr, hint <b>Type</b>) exprKind {
		<a href="../../src/go/types/expr.go.html#line-1318" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1318">#L1318</a>: 		var typ, base <b>Type</b>
		<a href="../../src/go/types/expr.go.html#line-1471" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1471">#L1471</a>: 			visited := make(map[any][]<b>Type</b>, len(e.Elts))
		<a href="../../src/go/types/expr.go.html#line-1594" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1594">#L1594</a>: 			var base <b>Type</b>
		<a href="../../src/go/types/expr.go.html#line-1595" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1595">#L1595</a>: 			if !underIs(x.typ, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/expr.go.html#line-1684" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1684">#L1684</a>: func (check *Checker) typeAssertion(e ast.Expr, x *operand, T <b>Type</b>, typeSwitch bool) {
		<a href="../../src/go/types/expr.go.html#line-1720" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1720">#L1720</a>: func (check *Checker) exprWithHint(x *operand, e ast.Expr, hint <b>Type</b>) {
		<a href="../../src/go/types/index.go.html#line-108">index.go#L108</a>: 		var key, elem <b>Type</b> // key != nil: we must have all maps
		<a href="../../src/go/types/index.go.html#line-111" class="path-duplicate">index.go</a><a href="../../src/go/types/index.go.html#line-111">#L111</a>: 		if typ.typeSet().underIs(func(u <b>Type</b>) bool {
		<a href="../../src/go/types/index.go.html#line-113" class="path-duplicate">index.go</a><a href="../../src/go/types/index.go.html#line-113">#L113</a>: 			var k, e <b>Type</b>  // k is only set for maps
		<a href="../../src/go/types/index.go.html#line-347" class="path-duplicate">index.go</a><a href="../../src/go/types/index.go.html#line-347">#L347</a>: func (check *Checker) index(index ast.Expr, max int64) (typ <b>Type</b>, val int64) {
		<a href="../../src/go/types/index.go.html#line-415" class="path-duplicate">index.go</a><a href="../../src/go/types/index.go.html#line-415">#L415</a>: func (check *Checker) indexedElts(elts []ast.Expr, typ <b>Type</b>, length int64) int64 {
		<a href="../../src/go/types/infer.go.html#line-32">infer.go#L32</a>: func (check *Checker) infer(posn positioner, tparams []*TypeParam, targs []<b>Type</b>, params *Tuple, args []*operand) (result []<b>Type</b>) {
		<a href="../../src/go/types/infer.go.html#line-179" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-179">#L179</a>: 		targs2 := make([]<b>Type</b>, n)
		<a href="../../src/go/types/infer.go.html#line-207" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-207">#L207</a>: 	errorf := func(kind string, tpar, targ <b>Type</b>, arg *operand) {
		<a href="../../src/go/types/infer.go.html#line-358" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-358">#L358</a>: func isParameterized(tparams []*TypeParam, typ <b>Type</b>) bool {
		<a href="../../src/go/types/infer.go.html#line-360" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-360">#L360</a>: 		seen:    make(map[<b>Type</b>]bool),
		<a href="../../src/go/types/infer.go.html#line-367" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-367">#L367</a>: 	seen    map[<b>Type</b>]bool
		<a href="../../src/go/types/infer.go.html#line-371" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-371">#L371</a>: func (w *tpWalker) isParameterized(typ <b>Type</b>) (res bool) {
		<a href="../../src/go/types/infer.go.html#line-450" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-450">#L450</a>: func (w *tpWalker) isParameterizedTypeList(list []<b>Type</b>) bool {
		<a href="../../src/go/types/infer.go.html#line-467" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-467">#L467</a>: func (check *Checker) inferB(posn positioner, tparams []*TypeParam, targs []<b>Type</b>) (types []<b>Type</b>, index int) {
		<a href="../../src/go/types/infer.go.html#line-606" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-606">#L606</a>: 	w := cycleFinder{tparams, types, make(map[<b>Type</b>]bool)}
		<a href="../../src/go/types/infer.go.html#line-698" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-698">#L698</a>: 	types   []<b>Type</b>
		<a href="../../src/go/types/infer.go.html#line-699" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-699">#L699</a>: 	seen    map[<b>Type</b>]bool
		<a href="../../src/go/types/infer.go.html#line-702" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-702">#L702</a>: func (w *cycleFinder) typ(typ <b>Type</b>) {
		<a href="../../src/go/types/instantiate.go.html#line-42">instantiate.go#L42</a>: func Instantiate(ctxt *Context, orig <b>Type</b>, targs []<b>Type</b>, validate bool) (<b>Type</b>, error) {
		<a href="../../src/go/types/instantiate.go.html#line-66" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-66">#L66</a>: func (check *Checker) instance(pos token.Pos, orig <b>Type</b>, targs []<b>Type</b>, ctxt *Context) (res <b>Type</b>) {
		<a href="../../src/go/types/instantiate.go.html#line-82" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-82">#L82</a>: 		named.resolver = func(ctxt *Context, n *Named) (*TypeParamList, <b>Type</b>, *methodList) {
		<a href="../../src/go/types/instantiate.go.html#line-136" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-136">#L136</a>: func (check *Checker) verify(pos token.Pos, tparams []*TypeParam, targs []<b>Type</b>) (int, error) {
		<a href="../../src/go/types/instantiate.go.html#line-156" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-156">#L156</a>: func (check *Checker) implements(V, T <b>Type</b>) error {
		<a href="../../src/go/types/instantiate.go.html#line-230" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-230">#L230</a>: 	var alt <b>Type</b>
		<a href="../../src/go/types/interface.go.html#line-20">interface.go#L20</a>: 	embeddeds []<b>Type</b>       // ordered list of explicitly embedded elements
		<a href="../../src/go/types/interface.go.html#line-40" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-40">#L40</a>: 	tnames := make([]<b>Type</b>, len(embeddeds))
		<a href="../../src/go/types/interface.go.html#line-53" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-53">#L53</a>: func NewInterfaceType(methods []*Func, embeddeds []<b>Type</b>) *Interface {
		<a href="../../src/go/types/interface.go.html#line-110" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-110">#L110</a>: func (t *Interface) EmbeddedType(i int) <b>Type</b> { return t.embeddeds[i] }
		<a href="../../src/go/types/interface.go.html#line-147" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-147">#L147</a>: func (t *Interface) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/interface.go.html#line-159" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-159">#L159</a>: 	addEmbedded := func(pos token.Pos, typ <b>Type</b>) {
		<a href="../../src/go/types/interface.go.html#line-202" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-202">#L202</a>: 		var recvTyp <b>Type</b> = ityp
		<a href="../../src/go/types/lookup.go.html#line-44">lookup.go#L44</a>: func LookupFieldOrMethod(T <b>Type</b>, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool) {
		<a href="../../src/go/types/lookup.go.html#line-89" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-89">#L89</a>: func lookupFieldOrMethod(T <b>Type</b>, addressable bool, pkg *Package, name string, foldCase bool) (obj Object, index []int, indirect bool) {
		<a href="../../src/go/types/lookup.go.html#line-220" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-220">#L220</a>: 	typ       <b>Type</b>
		<a href="../../src/go/types/lookup.go.html#line-235" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-235">#L235</a>: 	prev := make(map[<b>Type</b>]int) // index at which type was previously seen
		<a href="../../src/go/types/lookup.go.html#line-249" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-249">#L249</a>: func lookupType(m map[<b>Type</b>]int, typ <b>Type</b>) (int, bool) {
		<a href="../../src/go/types/lookup.go.html#line-294" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-294">#L294</a>: func MissingMethod(V <b>Type</b>, T *Interface, static bool) (method *Func, wrongType bool) {
		<a href="../../src/go/types/lookup.go.html#line-308" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-308">#L308</a>: func (check *Checker) missingMethod(V <b>Type</b>, T *Interface, static bool) (method, alt *Func) {
		<a href="../../src/go/types/lookup.go.html#line-374" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-374">#L374</a>: func (check *Checker) missingMethodReason(V, T <b>Type</b>, m, alt *Func) string {
		<a href="../../src/go/types/lookup.go.html#line-407" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-407">#L407</a>: func isInterfacePtr(T <b>Type</b>) bool {
		<a href="../../src/go/types/lookup.go.html#line-413" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-413">#L413</a>: func (check *Checker) interfacePtrError(T <b>Type</b>) string {
		<a href="../../src/go/types/lookup.go.html#line-438" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-438">#L438</a>: func (check *Checker) assertableTo(V *Interface, T <b>Type</b>) (method, wrongType *Func) {
		<a href="../../src/go/types/lookup.go.html#line-452" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-452">#L452</a>: func (check *Checker) newAssertableTo(V *Interface, T <b>Type</b>) error {
		<a href="../../src/go/types/lookup.go.html#line-464" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-464">#L464</a>: func deref(typ <b>Type</b>) (<b>Type</b>, bool) {
		<a href="../../src/go/types/lookup.go.html#line-480" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-480">#L480</a>: func derefStructPtr(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/map.go.html#line-9">map.go#L9</a>: 	key, elem <b>Type</b>
		<a href="../../src/go/types/map.go.html#line-13" class="path-duplicate">map.go</a><a href="../../src/go/types/map.go.html#line-13">#L13</a>: func NewMap(key, elem <b>Type</b>) *Map {
		<a href="../../src/go/types/map.go.html#line-18" class="path-duplicate">map.go</a><a href="../../src/go/types/map.go.html#line-18">#L18</a>: func (m *Map) Key() <b>Type</b> { return m.key }
		<a href="../../src/go/types/map.go.html#line-21" class="path-duplicate">map.go</a><a href="../../src/go/types/map.go.html#line-21">#L21</a>: func (m *Map) Elem() <b>Type</b> { return m.elem }
		<a href="../../src/go/types/map.go.html#line-23" class="path-duplicate">map.go</a><a href="../../src/go/types/map.go.html#line-23">#L23</a>: func (t *Map) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/methodset.go.html#line-72">methodset.go#L72</a>: func NewMethodSet(T <b>Type</b>) *MethodSet {
		<a href="../../src/go/types/mono.go.html#line-79">mono.go#L79</a>: 	typ <b>Type</b>
		<a href="../../src/go/types/mono.go.html#line-170" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-170">#L170</a>: func (w *monoGraph) recordInstance(pkg *Package, pos token.Pos, tparams []*TypeParam, targs []<b>Type</b>, xlist []ast.Expr) {
		<a href="../../src/go/types/mono.go.html#line-181" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-181">#L181</a>: func (w *monoGraph) assign(pkg *Package, pos token.Pos, tpar *TypeParam, targ <b>Type</b>) {
		<a href="../../src/go/types/mono.go.html#line-195" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-195">#L195</a>: 	flow := func(src int, typ <b>Type</b>) {
		<a href="../../src/go/types/mono.go.html#line-206" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-206">#L206</a>: 	var do func(typ <b>Type</b>)
		<a href="../../src/go/types/mono.go.html#line-207" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-207">#L207</a>: 	do = func(typ <b>Type</b>) {
		<a href="../../src/go/types/mono.go.html#line-326" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-326">#L326</a>: func (w *monoGraph) addEdge(dst, src, weight int, pos token.Pos, typ <b>Type</b>) {
		<a href="../../src/go/types/named.go.html#line-17">named.go#L17</a>: 	fromRHS    <b>Type</b>           // type (on RHS of declaration) this *Named type is derived of (for cycle reporting)
		<a href="../../src/go/types/named.go.html#line-18" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-18">#L18</a>: 	underlying <b>Type</b>           // possibly a *Named during setup; never a *Named once set up completely
		<a href="../../src/go/types/named.go.html#line-30" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-30">#L30</a>: 	resolver func(*Context, *Named) (tparams *TypeParamList, underlying <b>Type</b>, methods *methodList)
		<a href="../../src/go/types/named.go.html#line-37" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-37">#L37</a>: func NewNamed(obj *TypeName, underlying <b>Type</b>, methods []*Func) *Named {
		<a href="../../src/go/types/named.go.html#line-65" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-65">#L65</a>: func (check *Checker) newNamed(obj *TypeName, orig *Named, underlying <b>Type</b>, tparams *TypeParamList, methods *methodList) *Named {
		<a href="../../src/go/types/named.go.html#line-188" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-188">#L188</a>: 	var rtyp <b>Type</b>
		<a href="../../src/go/types/named.go.html#line-201" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-201">#L201</a>: func (t *Named) SetUnderlying(underlying <b>Type</b>) {
		<a href="../../src/go/types/named.go.html#line-226" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-226">#L226</a>: func (t *Named) Underlying() <b>Type</b> { return t.resolve(nil).underlying }
		<a href="../../src/go/types/named.go.html#line-250" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-250">#L250</a>: func (n0 *Named) under() <b>Type</b> {
		<a href="../../src/go/types/named.go.html#line-320" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-320">#L320</a>: func (n *Named) setUnderlying(typ <b>Type</b>) {
		<a href="../../src/go/types/named.go.html#line-358" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-358">#L358</a>: func expandNamed(ctxt *Context, n *Named, instPos token.Pos) (tparams *TypeParamList, underlying <b>Type</b>, methods *methodList) {
		<a href="../../src/go/types/named.go.html#line-410" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-410">#L410</a>: func safeUnderlying(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/object.go.html#line-23">object.go#L23</a>: 	Type() <b>Type</b>     // object type
		<a href="../../src/go/types/object.go.html#line-40" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-40">#L40</a>: 	setType(<b>Type</b>)
		<a href="../../src/go/types/object.go.html#line-87" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-87">#L87</a>: 	typ       <b>Type</b>
		<a href="../../src/go/types/object.go.html#line-117" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-117">#L117</a>: func colorFor(t <b>Type</b>) color {
		<a href="../../src/go/types/object.go.html#line-139" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-139">#L139</a>: func (obj *object) Type() <b>Type</b> { return obj.typ }
		<a href="../../src/go/types/object.go.html#line-155" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-155">#L155</a>: func (obj *object) setType(typ <b>Type</b>)          { obj.typ = typ }
		<a href="../../src/go/types/object.go.html#line-208" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-208">#L208</a>: func NewConst(pos token.Pos, pkg *Package, name string, typ <b>Type</b>, val constant.Value) *Const {
		<a href="../../src/go/types/object.go.html#line-229" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-229">#L229</a>: func NewTypeName(pos token.Pos, pkg *Package, name string, typ <b>Type</b>) *TypeName {
		<a href="../../src/go/types/object.go.html#line-235" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-235">#L235</a>: func _NewTypeNameLazy(pos token.Pos, pkg *Package, name string, load func(named *Named) (tparams []*TypeParam, underlying <b>Type</b>, methods []*Func)) *TypeName {
		<a href="../../src/go/types/object.go.html#line-238" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-238">#L238</a>: 	resolve := func(_ *Context, t *Named) (*TypeParamList, <b>Type</b>, *methodList) {
		<a href="../../src/go/types/object.go.html#line-289" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-289">#L289</a>: func NewVar(pos token.Pos, pkg *Package, name string, typ <b>Type</b>) *Var {
		<a href="../../src/go/types/object.go.html#line-294" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-294">#L294</a>: func NewParam(pos token.Pos, pkg *Package, name string, typ <b>Type</b>) *Var {
		<a href="../../src/go/types/object.go.html#line-301" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-301">#L301</a>: func NewField(pos token.Pos, pkg *Package, name string, typ <b>Type</b>, embedded bool) *Var {
		<a href="../../src/go/types/object.go.html#line-329" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-329">#L329</a>: 	var typ <b>Type</b>
		<a href="../../src/go/types/operand.go.html#line-56">operand.go#L56</a>: 	typ  <b>Type</b>
		<a href="../../src/go/types/operand.go.html#line-234" class="path-duplicate">operand.go</a><a href="../../src/go/types/operand.go.html#line-234">#L234</a>: func (x *operand) assignableTo(check *Checker, T <b>Type</b>, reason *string) (bool, errorCode) {
		<a href="../../src/go/types/pointer.go.html#line-9">pointer.go#L9</a>: 	base <b>Type</b> // element type
		<a href="../../src/go/types/pointer.go.html#line-13" class="path-duplicate">pointer.go</a><a href="../../src/go/types/pointer.go.html#line-13">#L13</a>: func NewPointer(elem <b>Type</b>) *Pointer { return &amp;Pointer{base: elem} }
		<a href="../../src/go/types/pointer.go.html#line-16" class="path-duplicate">pointer.go</a><a href="../../src/go/types/pointer.go.html#line-16">#L16</a>: func (p *Pointer) Elem() <b>Type</b> { return p.base }
		<a href="../../src/go/types/pointer.go.html#line-18" class="path-duplicate">pointer.go</a><a href="../../src/go/types/pointer.go.html#line-18">#L18</a>: func (t *Pointer) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/predicates.go.html#line-15">predicates.go#L15</a>: func isBoolean(t <b>Type</b>) bool        { return isBasic(t, IsBoolean) }
		<a href="../../src/go/types/predicates.go.html#line-16" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-16">#L16</a>: func isInteger(t <b>Type</b>) bool        { return isBasic(t, IsInteger) }
		<a href="../../src/go/types/predicates.go.html#line-17" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-17">#L17</a>: func isUnsigned(t <b>Type</b>) bool       { return isBasic(t, IsUnsigned) }
		<a href="../../src/go/types/predicates.go.html#line-18" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-18">#L18</a>: func isFloat(t <b>Type</b>) bool          { return isBasic(t, IsFloat) }
		<a href="../../src/go/types/predicates.go.html#line-19" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-19">#L19</a>: func isComplex(t <b>Type</b>) bool        { return isBasic(t, IsComplex) }
		<a href="../../src/go/types/predicates.go.html#line-20" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-20">#L20</a>: func isNumeric(t <b>Type</b>) bool        { return isBasic(t, IsNumeric) }
		<a href="../../src/go/types/predicates.go.html#line-21" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-21">#L21</a>: func isString(t <b>Type</b>) bool         { return isBasic(t, IsString) }
		<a href="../../src/go/types/predicates.go.html#line-22" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-22">#L22</a>: func isIntegerOrFloat(t <b>Type</b>) bool { return isBasic(t, IsInteger|IsFloat) }
		<a href="../../src/go/types/predicates.go.html#line-23" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-23">#L23</a>: func isConstType(t <b>Type</b>) bool      { return isBasic(t, IsConstType) }
		<a href="../../src/go/types/predicates.go.html#line-28" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-28">#L28</a>: func isBasic(t <b>Type</b>, info BasicInfo) bool {
		<a href="../../src/go/types/predicates.go.html#line-39" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-39">#L39</a>: func allBoolean(typ <b>Type</b>) bool         { return allBasic(typ, IsBoolean) }
		<a href="../../src/go/types/predicates.go.html#line-40" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-40">#L40</a>: func allInteger(typ <b>Type</b>) bool         { return allBasic(typ, IsInteger) }
		<a href="../../src/go/types/predicates.go.html#line-41" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-41">#L41</a>: func allUnsigned(typ <b>Type</b>) bool        { return allBasic(typ, IsUnsigned) }
		<a href="../../src/go/types/predicates.go.html#line-42" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-42">#L42</a>: func allNumeric(typ <b>Type</b>) bool         { return allBasic(typ, IsNumeric) }
		<a href="../../src/go/types/predicates.go.html#line-43" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-43">#L43</a>: func allString(typ <b>Type</b>) bool          { return allBasic(typ, IsString) }
		<a href="../../src/go/types/predicates.go.html#line-44" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-44">#L44</a>: func allOrdered(typ <b>Type</b>) bool         { return allBasic(typ, IsOrdered) }
		<a href="../../src/go/types/predicates.go.html#line-45" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-45">#L45</a>: func allNumericOrString(typ <b>Type</b>) bool { return allBasic(typ, IsNumeric|IsString) }
		<a href="../../src/go/types/predicates.go.html#line-51" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-51">#L51</a>: func allBasic(t <b>Type</b>, info BasicInfo) bool {
		<a href="../../src/go/types/predicates.go.html#line-61" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-61">#L61</a>: func hasName(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-72" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-72">#L72</a>: func isTyped(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-80" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-80">#L80</a>: func isUntyped(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-85" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-85">#L85</a>: func IsInterface(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-91" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-91">#L91</a>: func isTypeParam(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-99" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-99">#L99</a>: func isGeneric(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-106" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-106">#L106</a>: func Comparable(T <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-112" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-112">#L112</a>: func comparable(T <b>Type</b>, dynamic bool, seen map[<b>Type</b>]bool, reportf func(string, ...interface{})) bool {
		<a href="../../src/go/types/predicates.go.html#line-117" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-117">#L117</a>: 		seen = make(map[<b>Type</b>]bool)
		<a href="../../src/go/types/predicates.go.html#line-153" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-153">#L153</a>: func hasNil(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-160" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-160">#L160</a>: 		return !isTypeParam(t) || u.typeSet().underIs(func(u <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-178" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-178">#L178</a>: func identical(x, y <b>Type</b>, cmpTags bool, p *ifacePair) bool {
		<a href="../../src/go/types/predicates.go.html#line-277" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-277">#L277</a>: 			var targs []<b>Type</b>
		<a href="../../src/go/types/predicates.go.html#line-434" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-434">#L434</a>: func identicalInstance(xorig <b>Type</b>, xargs []<b>Type</b>, yorig <b>Type</b>, yargs []<b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-451" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-451">#L451</a>: func Default(t <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/scope.go.html#line-281">scope.go#L281</a>: func (*lazyObject) Type() <b>Type</b>                            { panic("unreachable") }
		<a href="../../src/go/types/scope.go.html#line-287" class="path-duplicate">scope.go</a><a href="../../src/go/types/scope.go.html#line-287">#L287</a>: func (*lazyObject) setType(<b>Type</b>)                          { panic("unreachable") }
		<a href="../../src/go/types/selection.go.html#line-42">selection.go#L42</a>: 	recv     <b>Type</b>   // type of x
		<a href="../../src/go/types/selection.go.html#line-52" class="path-duplicate">selection.go</a><a href="../../src/go/types/selection.go.html#line-52">#L52</a>: func (s *Selection) Recv() <b>Type</b> { return s.recv }
		<a href="../../src/go/types/selection.go.html#line-60" class="path-duplicate">selection.go</a><a href="../../src/go/types/selection.go.html#line-60">#L60</a>: func (s *Selection) Type() <b>Type</b> {
		<a href="../../src/go/types/signature.go.html#line-95">signature.go#L95</a>: func (t *Signature) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/signature.go.html#line-238" class="path-duplicate">signature.go</a><a href="../../src/go/types/signature.go.html#line-238">#L238</a>: 						underIs(T, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/sizes.go.html#line-13">sizes.go#L13</a>: 	Alignof(T <b>Type</b>) int64
		<a href="../../src/go/types/sizes.go.html#line-21" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-21">#L21</a>: 	Sizeof(T <b>Type</b>) int64
		<a href="../../src/go/types/sizes.go.html#line-48" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-48">#L48</a>: func (s *StdSizes) Alignof(T <b>Type</b>) int64 {
		<a href="../../src/go/types/sizes.go.html#line-125" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-125">#L125</a>: func (s *StdSizes) Sizeof(T <b>Type</b>) int64 {
		<a href="../../src/go/types/sizes.go.html#line-214" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-214">#L214</a>: func (conf *Config) alignof(T <b>Type</b>) int64 {
		<a href="../../src/go/types/sizes.go.html#line-249" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-249">#L249</a>: func (conf *Config) offsetof(typ <b>Type</b>, index []int) int64 {
		<a href="../../src/go/types/sizes.go.html#line-259" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-259">#L259</a>: func (conf *Config) sizeof(T <b>Type</b>) int64 {
		<a href="../../src/go/types/slice.go.html#line-9">slice.go#L9</a>: 	elem <b>Type</b>
		<a href="../../src/go/types/slice.go.html#line-13" class="path-duplicate">slice.go</a><a href="../../src/go/types/slice.go.html#line-13">#L13</a>: func NewSlice(elem <b>Type</b>) *Slice { return &amp;Slice{elem: elem} }
		<a href="../../src/go/types/slice.go.html#line-16" class="path-duplicate">slice.go</a><a href="../../src/go/types/slice.go.html#line-16">#L16</a>: func (s *Slice) Elem() <b>Type</b> { return s.elem }
		<a href="../../src/go/types/slice.go.html#line-18" class="path-duplicate">slice.go</a><a href="../../src/go/types/slice.go.html#line-18">#L18</a>: func (t *Slice) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/stmt.go.html#line-233">stmt.go#L233</a>: 		typ <b>Type</b>
		<a href="../../src/go/types/stmt.go.html#line-285" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-285">#L285</a>: func (check *Checker) caseTypes(x *operand, types []ast.Expr, seen map[<b>Type</b>]ast.Expr) (T <b>Type</b>) {
		<a href="../../src/go/types/stmt.go.html#line-702" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-702">#L702</a>: 		seen := make(map[<b>Type</b>]ast.Expr) // map of seen types to positions
		<a href="../../src/go/types/stmt.go.html#line-830" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-830">#L830</a>: 		var key, val <b>Type</b>
		<a href="../../src/go/types/stmt.go.html#line-868" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-868">#L868</a>: 		rhs := [2]<b>Type</b>{key, val} // key, val may be nil
		<a href="../../src/go/types/stmt.go.html#line-940" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-940">#L940</a>: func rangeKeyVal(typ <b>Type</b>) (key, val <b>Type</b>) {
		<a href="../../src/go/types/struct.go.html#line-55">struct.go#L55</a>: func (t *Struct) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/struct.go.html#line-82" class="path-duplicate">struct.go</a><a href="../../src/go/types/struct.go.html#line-82">#L82</a>: 	var typ <b>Type</b>
		<a href="../../src/go/types/subst.go.html#line-11">subst.go#L11</a>: type substMap map[*TypeParam]<b>Type</b>
		<a href="../../src/go/types/subst.go.html#line-15" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-15">#L15</a>: func makeSubstMap(tpars []*TypeParam, targs []<b>Type</b>) substMap {
		<a href="../../src/go/types/subst.go.html#line-39" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-39">#L39</a>: func (m substMap) lookup(tpar *TypeParam) <b>Type</b> {
		<a href="../../src/go/types/subst.go.html#line-52" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-52">#L52</a>: func (check *Checker) subst(pos token.Pos, typ <b>Type</b>, smap substMap, ctxt *Context) <b>Type</b> {
		<a href="../../src/go/types/subst.go.html#line-82" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-82">#L82</a>: func (subst *subster) typ(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/subst.go.html#line-221" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-221">#L221</a>: 		var newTArgs []<b>Type</b>
		<a href="../../src/go/types/subst.go.html#line-237" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-237">#L237</a>: 					newTArgs = make([]<b>Type</b>, t.orig.TypeParams().Len())
		<a href="../../src/go/types/subst.go.html#line-283" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-283">#L283</a>: func (subst *subster) typOrNil(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/subst.go.html#line-299" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-299">#L299</a>: func substVar(v *Var, typ <b>Type</b>) *Var {
		<a href="../../src/go/types/subst.go.html#line-361" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-361">#L361</a>: func (subst *subster) typeList(in []<b>Type</b>) (out []<b>Type</b>, copied bool) {
		<a href="../../src/go/types/subst.go.html#line-368" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-368">#L368</a>: 				new := make([]<b>Type</b>, len(in))
		<a href="../../src/go/types/subst.go.html#line-403" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-403">#L403</a>: func replaceRecvType(in []*Func, old, new <b>Type</b>) (out []*Func, copied bool) {
		<a href="../../src/go/types/termlist.go.html#line-126">termlist.go#L126</a>: func (xl termlist) includes(t <b>Type</b>) bool {
		<a href="../../src/go/types/tuple.go.html#line-33">tuple.go#L33</a>: func (t *Tuple) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/type.go.html#line-9">type.go#L9</a>: type <b>Type</b> interface {
		<a href="../../src/go/types/type.go.html#line-11" class="path-duplicate">type.go</a><a href="../../src/go/types/type.go.html#line-11">#L11</a>: 	Underlying() <b>Type</b>
		<a href="../../src/go/types/type.go.html#line-21" class="path-duplicate">type.go</a><a href="../../src/go/types/type.go.html#line-21">#L21</a>: func under(t <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/type.go.html#line-34" class="path-duplicate">type.go</a><a href="../../src/go/types/type.go.html#line-34">#L34</a>: func coreType(t <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/type.go.html#line-40" class="path-duplicate">type.go</a><a href="../../src/go/types/type.go.html#line-40">#L40</a>: 	var su <b>Type</b>
		<a href="../../src/go/types/type.go.html#line-41" class="path-duplicate">type.go</a><a href="../../src/go/types/type.go.html#line-41">#L41</a>: 	if tpar.underIs(func(u <b>Type</b>) bool {
		<a href="../../src/go/types/type.go.html#line-63" class="path-duplicate">type.go</a><a href="../../src/go/types/type.go.html#line-63">#L63</a>: func coreString(t <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/type.go.html#line-69" class="path-duplicate">type.go</a><a href="../../src/go/types/type.go.html#line-69">#L69</a>: 	var su <b>Type</b>
		<a href="../../src/go/types/type.go.html#line-71" class="path-duplicate">type.go</a><a href="../../src/go/types/type.go.html#line-71">#L71</a>: 	if tpar.underIs(func(u <b>Type</b>) bool {
		<a href="../../src/go/types/type.go.html#line-102" class="path-duplicate">type.go</a><a href="../../src/go/types/type.go.html#line-102">#L102</a>: func match(x, y <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/typelists.go.html#line-28">typelists.go#L28</a>: type TypeList struct{ types []<b>Type</b> }
		<a href="../../src/go/types/typelists.go.html#line-31" class="path-duplicate">typelists.go</a><a href="../../src/go/types/typelists.go.html#line-31">#L31</a>: func newTypeList(list []<b>Type</b>) *TypeList {
		<a href="../../src/go/types/typelists.go.html#line-43" class="path-duplicate">typelists.go</a><a href="../../src/go/types/typelists.go.html#line-43">#L43</a>: func (l *TypeList) At(i int) <b>Type</b> { return l.types[i] }
		<a href="../../src/go/types/typelists.go.html#line-48" class="path-duplicate">typelists.go</a><a href="../../src/go/types/typelists.go.html#line-48">#L48</a>: func (l *TypeList) list() []<b>Type</b> {
		<a href="../../src/go/types/typeparam.go.html#line-26">typeparam.go#L26</a>: 	bound <b>Type</b>      // any type, but underlying is eventually *Interface for correct programs (see TypeParam.iface)
		<a href="../../src/go/types/typeparam.go.html#line-35" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-35">#L35</a>: func NewTypeParam(obj *TypeName, constraint <b>Type</b>) *TypeParam {
		<a href="../../src/go/types/typeparam.go.html#line-40" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-40">#L40</a>: func (check *Checker) newTypeParam(obj *TypeName, constraint <b>Type</b>) *TypeParam {
		<a href="../../src/go/types/typeparam.go.html#line-71" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-71">#L71</a>: func (t *TypeParam) Constraint() <b>Type</b> {
		<a href="../../src/go/types/typeparam.go.html#line-81" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-81">#L81</a>: func (t *TypeParam) SetConstraint(bound <b>Type</b>) {
		<a href="../../src/go/types/typeparam.go.html#line-91" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-91">#L91</a>: func (t *TypeParam) Underlying() <b>Type</b> {
		<a href="../../src/go/types/typeparam.go.html#line-127" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-127">#L127</a>: 		ityp = NewInterfaceType(nil, []<b>Type</b>{bound})
		<a href="../../src/go/types/typeparam.go.html#line-156" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-156">#L156</a>: func (t *TypeParam) underIs(f func(<b>Type</b>) bool) bool {
		<a href="../../src/go/types/typeset.go.html#line-42">typeset.go#L42</a>: func (s *_TypeSet) IsComparable(seen map[<b>Type</b>]bool) bool {
		<a href="../../src/go/types/typeset.go.html#line-128" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-128">#L128</a>: func (s *_TypeSet) underIs(f func(<b>Type</b>) bool) bool {
		<a href="../../src/go/types/typestring.go.html#line-49">typestring.go#L49</a>: func TypeString(typ <b>Type</b>, qf Qualifier) string {
		<a href="../../src/go/types/typestring.go.html#line-53" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-53">#L53</a>: func typeString(typ <b>Type</b>, qf Qualifier, debug bool) string {
		<a href="../../src/go/types/typestring.go.html#line-64" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-64">#L64</a>: func WriteType(buf *bytes.Buffer, typ <b>Type</b>, qf Qualifier) {
		<a href="../../src/go/types/typestring.go.html#line-78" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-78">#L78</a>: 	seen    map[<b>Type</b>]bool
		<a href="../../src/go/types/typestring.go.html#line-86" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-86">#L86</a>: 	return &amp;typeWriter{buf, make(map[<b>Type</b>]bool), qf, nil, nil, false}
		<a href="../../src/go/types/typestring.go.html#line-91" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-91">#L91</a>: 	return &amp;typeWriter{buf, make(map[<b>Type</b>]bool), nil, ctxt, nil, false}
		<a href="../../src/go/types/typestring.go.html#line-119" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-119">#L119</a>: func (w *typeWriter) typ(typ <b>Type</b>) {
		<a href="../../src/go/types/typestring.go.html#line-357" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-357">#L357</a>: func (w *typeWriter) typeList(list []<b>Type</b>) {
		<a href="../../src/go/types/typestring.go.html#line-370" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-370">#L370</a>: 	var prev <b>Type</b>
		<a href="../../src/go/types/typeterm.go.html#line-16">typeterm.go#L16</a>: 	typ   <b>Type</b>
		<a href="../../src/go/types/typeterm.go.html#line-107" class="path-duplicate">typeterm.go</a><a href="../../src/go/types/typeterm.go.html#line-107">#L107</a>: func (x *term) includes(t <b>Type</b>) bool {
		<a href="../../src/go/types/typexpr.go.html#line-138">typexpr.go#L138</a>: func (check *Checker) typ(e ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/typexpr.go.html#line-145" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-145">#L145</a>: func (check *Checker) varType(e ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/typexpr.go.html#line-153" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-153">#L153</a>: func (check *Checker) validVarType(e ast.Expr, typ <b>Type</b>) {
		<a href="../../src/go/types/typexpr.go.html#line-181" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-181">#L181</a>: func (check *Checker) definedType(e ast.Expr, def *Named) <b>Type</b> {
		<a href="../../src/go/types/typexpr.go.html#line-195" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-195">#L195</a>: func (check *Checker) genericType(e ast.Expr, reason *string) <b>Type</b> {
		<a href="../../src/go/types/typexpr.go.html#line-211" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-211">#L211</a>: func goTypeName(typ <b>Type</b>) string {
		<a href="../../src/go/types/typexpr.go.html#line-218" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-218">#L218</a>: func (check *Checker) typInternal(e0 ast.Expr, def *Named) (T <b>Type</b>) {
		<a href="../../src/go/types/typexpr.go.html#line-224" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-224">#L224</a>: 			var under <b>Type</b>
		<a href="../../src/go/types/typexpr.go.html#line-393" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-393">#L393</a>: func (check *Checker) instantiatedType(ix *typeparams.IndexExpr, def *Named) (res <b>Type</b>) {
		<a href="../../src/go/types/typexpr.go.html#line-448" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-448">#L448</a>: 	inst.resolver = func(ctxt *Context, n *Named) (*TypeParamList, <b>Type</b>, *methodList) {
		<a href="../../src/go/types/typexpr.go.html#line-541" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-541">#L541</a>: func (check *Checker) typeList(list []ast.Expr) []<b>Type</b> {
		<a href="../../src/go/types/typexpr.go.html#line-542" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-542">#L542</a>: 	res := make([]<b>Type</b>, len(list)) // res != nil even if len(list) == 0
		<a href="../../src/go/types/unify.go.html#line-66">unify.go#L66</a>: 	types []<b>Type</b>      // inferred types, shared by x and y
		<a href="../../src/go/types/unify.go.html#line-84" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-84">#L84</a>: func (u *unifier) unify(x, y <b>Type</b>) bool {
		<a href="../../src/go/types/unify.go.html#line-187" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-187">#L187</a>: func (d *tparamsList) index(typ <b>Type</b>) int {
		<a href="../../src/go/types/unify.go.html#line-223" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-223">#L223</a>: func (d *tparamsList) at(i int) <b>Type</b> {
		<a href="../../src/go/types/unify.go.html#line-232" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-232">#L232</a>: func (d *tparamsList) set(i int, typ <b>Type</b>) {
		<a href="../../src/go/types/unify.go.html#line-265" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-265">#L265</a>: func (d *tparamsList) types() (list []<b>Type</b>, index int) {
		<a href="../../src/go/types/unify.go.html#line-266" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-266">#L266</a>: 	list = make([]<b>Type</b>, len(d.tparams))
		<a href="../../src/go/types/unify.go.html#line-278" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-278">#L278</a>: func (u *unifier) nifyEq(x, y <b>Type</b>, p *ifacePair) bool {
		<a href="../../src/go/types/unify.go.html#line-286" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-286">#L286</a>: func (u *unifier) nify(x, y <b>Type</b>, p *ifacePair) (result bool) {
		<a href="../../src/go/types/union.go.html#line-32">union.go#L32</a>: func (u *Union) Underlying() <b>Type</b> { return u }
		<a href="../../src/go/types/union.go.html#line-39" class="path-duplicate">union.go</a><a href="../../src/go/types/union.go.html#line-39">#L39</a>: func NewTerm(tilde bool, typ <b>Type</b>) *Term { return &amp;Term{tilde, typ} }
		<a href="../../src/go/types/union.go.html#line-42" class="path-duplicate">union.go</a><a href="../../src/go/types/union.go.html#line-42">#L42</a>: func (t *Term) Type() <b>Type</b>     { return t.typ }
		<a href="../../src/go/types/union.go.html#line-53" class="path-duplicate">union.go</a><a href="../../src/go/types/union.go.html#line-53">#L53</a>: func parseUnion(check *Checker, uexpr ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/union.go.html#line-59" class="path-duplicate">union.go</a><a href="../../src/go/types/union.go.html#line-59">#L59</a>: 	var u <b>Type</b>
		<a href="../../src/go/types/universe.go.html#line-25">universe.go#L25</a>: 	universeByte       <b>Type</b> // uint8 alias, but has name "byte"
		<a href="../../src/go/types/universe.go.html#line-26" class="path-duplicate">universe.go</a><a href="../../src/go/types/universe.go.html#line-26">#L26</a>: 	universeRune       <b>Type</b> // int32 alias, but has name "rune"
		<a href="../../src/go/types/universe.go.html#line-28" class="path-duplicate">universe.go</a><a href="../../src/go/types/universe.go.html#line-28">#L28</a>: 	universeError      <b>Type</b>
		<a href="../../src/go/types/validtype.go.html#line-23">validtype.go#L23</a>: func (check *Checker) validType0(typ <b>Type</b>, env *tparamEnv, path []Object) typeInfo {

	<a href="../../pkg/golang.org/x/exp/apidiff.html">golang.org/x/exp/apidiff</a>
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-43">apidiff.go#L43</a>: 	correspondMap map[*types.TypeName]types.<b>Type</b>
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-54" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-54">#L54</a>: 		correspondMap: map[*types.TypeName]types.<b>Type</b>{},
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-187" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-187">#L187</a>: func (d *differ) checkCorrespondence(obj types.Object, part string, old, new types.<b>Type</b>) {
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-193" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-193">#L193</a>: func (d *differ) typeChanged(obj types.Object, part string, old, new types.<b>Type</b>) {
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-204" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-204">#L204</a>: func removeNamesFromSignature(t types.<b>Type</b>) types.<b>Type</b> {
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-9">compatibility.go#L9</a>: func (d *differ) checkCompatible(otn *types.TypeName, old, new types.<b>Type</b>) {
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-261" class="path-duplicate">compatibility.go</a><a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-261">#L261</a>: func (d *differ) checkCompatibleDefined(otn *types.TypeName, old *types.Named, new types.<b>Type</b>) {
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-284" class="path-duplicate">compatibility.go</a><a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-284">#L284</a>: func (d *differ) checkMethodSet(otn *types.TypeName, oldt, newt types.<b>Type</b>, addcompat bool) {
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-334" class="path-duplicate">compatibility.go</a><a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-334">#L334</a>: func exportedMethods(t types.<b>Type</b>) map[string]types.Object {
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-346" class="path-duplicate">compatibility.go</a><a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-346">#L346</a>: func receiverType(method types.Object) types.<b>Type</b> {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-17">correspondence.go#L17</a>: func (d *differ) correspond(old, new types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-29" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-29">#L29</a>: func (d *differ) corr(old, new types.<b>Type</b>, p *ifacePair) bool {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-159" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-159">#L159</a>: func (d *differ) establishCorrespondence(old *types.Named, new types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-223" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-223">#L223</a>: func typesEquivalent(old, new types.<b>Type</b>) bool {

	<a href="../../pkg/golang.org/x/tools/internal/gcimporter.html">golang.org/x/tools/internal/gcimporter</a>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-69">bexport.go#L69</a>: 	typIndex map[types.<b>Type</b>]int
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-110" class="path-duplicate">bexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-110">#L110</a>: 		typIndex:      make(map[types.<b>Type</b>]int),
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-298" class="path-duplicate">bexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-298">#L298</a>: func (p *exporter) typ(t types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-521" class="path-duplicate">bexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bexport.go.html#line-521">#L521</a>: func basetypeName(typ types.<b>Type</b>) string {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-34">bimport.go#L34</a>: 	typList       []types.<b>Type</b>       // in order of appearance
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-398" class="path-duplicate">bimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-398">#L398</a>: func (p *importer) record(t types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-406" class="path-duplicate">bimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-406">#L406</a>: 	elem types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-409" class="path-duplicate">bimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-409">#L409</a>: func (t *dddSlice) Underlying() types.<b>Type</b> { return t }
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-420" class="path-duplicate">bimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-420">#L420</a>: func (p *importer) typ(parent *types.Package, tname *types.Named) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-550" class="path-duplicate">bimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-550">#L550</a>: 		var embeddeds []types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-995" class="path-duplicate">bimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-995">#L995</a>: var predecl []types.<b>Type</b> // initialized lazily
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-997" class="path-duplicate">bimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-997">#L997</a>: func predeclared() []types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-1001" class="path-duplicate">bimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-1001">#L1001</a>: 		predecl = []types.<b>Type</b>{ // basic types
		<a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-1052" class="path-duplicate">bimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/bimport.go.html#line-1052">#L1052</a>: func (t anyType) Underlying() types.<b>Type</b> { return t }
		<a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-537">gcimporter.go#L537</a>: func (p *parser) parseBasicType() types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-550" class="path-duplicate">gcimporter.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-550">#L550</a>: func (p *parser) parseArrayType(parent *types.Package) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-565" class="path-duplicate">gcimporter.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-565">#L565</a>: func (p *parser) parseMapType(parent *types.Package) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-614" class="path-duplicate">gcimporter.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-614">#L614</a>: func deref(typ types.<b>Type</b>) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-670" class="path-duplicate">gcimporter.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-670">#L670</a>: func (p *parser) parseStructType(parent *types.Package) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-773" class="path-duplicate">gcimporter.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-773">#L773</a>: func (p *parser) parseInterfaceType(parent *types.Package) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-796" class="path-duplicate">gcimporter.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-796">#L796</a>: func (p *parser) parseChanType(parent *types.Package) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-825" class="path-duplicate">gcimporter.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-825">#L825</a>: func (p *parser) parseType(parent *types.Package) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-949" class="path-duplicate">gcimporter.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-949">#L949</a>: 	var typ0 types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-956" class="path-duplicate">gcimporter.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/gcimporter.go.html#line-956">#L956</a>: 	var typ types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-105">iexport.go#L105</a>: 		typIndex:    map[types.<b>Type</b>]uint64{},
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-261" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-261">#L261</a>: 	typIndex    map[types.<b>Type</b>]uint64
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-552" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-552">#L552</a>: func (w *exportWriter) typ(t types.<b>Type</b>, pkg *types.Package) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-566" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-566">#L566</a>: func (p *iexporter) typOff(t types.<b>Type</b>, pkg *types.Package) uint64 {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-581" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-581">#L581</a>: func (w *exportWriter) doTyp(t types.<b>Type</b>, pkg *types.Package) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-786" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-786">#L786</a>: func (w *exportWriter) value(typ types.<b>Type</b>, v constant.Value) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-868" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-868">#L868</a>: func (w *exportWriter) mpint(x *big.Int, typ types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-936" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-936">#L936</a>: func (w *exportWriter) mpfloat(f *big.Float, typ types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-158">iimport.go#L158</a>: 		typCache: make(map[uint64]types.<b>Type</b>),
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-161" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-161">#L161</a>: 		tparamIndex: make(map[ident]types.<b>Type</b>),
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-271" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-271">#L271</a>: 	constraint types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-287" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-287">#L287</a>: 	typCache    map[uint64]types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-288" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-288">#L288</a>: 	tparamIndex map[ident]types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-364" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-364">#L364</a>: func (p *iimporter) typAt(off uint64, base *types.Named) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-389" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-389">#L389</a>: func canReuse(def *types.Named, rhs types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-521" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-521">#L521</a>: func (r *importReader) value() (typ types.<b>Type</b>, val constant.Value) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-684" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-684">#L684</a>: func (r *importReader) typ() types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-688" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-688">#L688</a>: func isInterface(t types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-696" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-696">#L696</a>: func (r *importReader) doType(base *types.Named) (res types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-751" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-751">#L751</a>: 		embeddeds := make([]types.<b>Type</b>, r.uint64())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-799" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-799">#L799</a>: 		targs := make([]types.<b>Type</b>, len)
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-890" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-890">#L890</a>: func baseType(typ types.<b>Type</b>) *types.Named {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/newInterface11.go^10e54.html#line-12">newInterface11.go#L12</a>: func newInterface(methods []*types.Func, embeddeds []types.<b>Type</b>) *types.Interface {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/support_go118.go.html#line-15">support_go118.go#L15</a>: func additionalPredeclared() []types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/support_go118.go.html#line-16" class="path-duplicate">support_go118.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/support_go118.go.html#line-16">#L16</a>: 	return []types.<b>Type</b>{
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-34">ureader_yes.go#L34</a>: 	typs     []types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-40" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-40">#L40</a>: 	laterFors map[types.<b>Type</b>]int
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-73" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-73">#L73</a>: func (pr *pkgReader) laterFor(t types.<b>Type</b>, fn func()) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-75" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-75">#L75</a>: 		pr.laterFors = make(map[types.<b>Type</b>]int)
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-97" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-97">#L97</a>: 		typs:     make([]types.<b>Type</b>, input.NumElems(pkgbits.RelocType)),
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-151" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-151">#L151</a>: 	derivedTypes []types.<b>Type</b> // lazily instantiated from derived
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-298" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-298">#L298</a>: func (r *reader) typ() types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-310" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-310">#L310</a>: func (pr *pkgReader) typIdx(info typeInfo, dict *readerDict) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-312" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-312">#L312</a>: 	var where *types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-324" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-324">#L324</a>: 	var typ types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-342" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-342">#L342</a>: func (r *reader) doTyp() (res types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-417" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-417">#L417</a>: 	embeddeds := make([]types.<b>Type</b>, r.Len())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-481" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-481">#L481</a>: func (r *reader) obj() (types.Object, []types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-489" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-489">#L489</a>: 	targs := make([]types.<b>Type</b>, r.Len())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-587" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-587">#L587</a>: 					embeds := make([]types.<b>Type</b>, iface.NumEmbeddeds())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-630" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-630">#L630</a>: 		dict.derivedTypes = make([]types.<b>Type</b>, len(dict.derived))
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-668" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-668">#L668</a>: 	typs := make([]types.<b>Type</b>, len(r.dict.bounds))

	<a href="../../pkg/golang.org/x/tools/internal/typeparams.html">golang.org/x/tools/internal/typeparams</a>
		<a href="../../src/golang.org/x/tools/internal/typeparams/common.go.html#line-75">common.go#L75</a>: func IsTypeParam(t types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/tools/internal/typeparams/common.go.html#line-135" class="path-duplicate">common.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/common.go.html#line-135">#L135</a>: func GenericAssignableTo(ctxt *Context, V, T types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/tools/internal/typeparams/common.go.html#line-163" class="path-duplicate">common.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/common.go.html#line-163">#L163</a>: 	var targs []types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/typeparams/coretype.go.html#line-14">coretype.go#L14</a>: func CoreType(T types.<b>Type</b>) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/typeparams/coretype.go.html#line-111" class="path-duplicate">coretype.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/coretype.go.html#line-111">#L111</a>: func _NormalTerms(typ types.<b>Type</b>) ([]*Term, error) {
		<a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-95">normalize.go#L95</a>: func computeTermSet(typ types.<b>Type</b>) ([]*Term, error) {
		<a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-96" class="path-duplicate">normalize.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-96">#L96</a>: 	tset, err := computeTermSetInternal(typ, make(map[types.<b>Type</b>]*termSet), 0)
		<a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-127" class="path-duplicate">normalize.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-127">#L127</a>: func computeTermSetInternal(t types.<b>Type</b>, seen map[types.<b>Type</b>]*termSet, depth int) (res *termSet, err error) {
		<a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-216" class="path-duplicate">normalize.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-216">#L216</a>: func under(t types.<b>Type</b>) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/typeparams/termlist.go.html#line-131">termlist.go#L131</a>: func (xl termlist) includes(t types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/tools/internal/typeparams/typeparams_go118.go.html#line-44">typeparams_go118.go#L44</a>: func NewTypeParam(name *types.TypeName, constraint types.<b>Type</b>) *TypeParam {
		<a href="../../src/golang.org/x/tools/internal/typeparams/typeparams_go118.go.html#line-49" class="path-duplicate">typeparams_go118.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/typeparams_go118.go.html#line-49">#L49</a>: func SetTypeParamConstraint(tparam *TypeParam, constraint types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/typeparams/typeparams_go118.go.html#line-106" class="path-duplicate">typeparams_go118.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/typeparams_go118.go.html#line-106">#L106</a>: func NamedTypeOrigin(named *types.Named) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/typeparams/typeparams_go118.go.html#line-114" class="path-duplicate">typeparams_go118.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/typeparams_go118.go.html#line-114">#L114</a>: func NewTerm(tilde bool, typ types.<b>Type</b>) *Term {
		<a href="../../src/golang.org/x/tools/internal/typeparams/typeparams_go118.go.html#line-149" class="path-duplicate">typeparams_go118.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/typeparams_go118.go.html#line-149">#L149</a>: func Instantiate(ctxt *Context, typ types.<b>Type</b>, targs []types.<b>Type</b>, validate bool) (types.<b>Type</b>, error) {
		<a href="../../src/golang.org/x/tools/internal/typeparams/typeterm.go.html#line-20">typeterm.go#L20</a>: 	typ   types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/typeparams/typeterm.go.html#line-111" class="path-duplicate">typeterm.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/typeterm.go.html#line-111">#L111</a>: func (x *term) includes(t types.<b>Type</b>) bool {
</code></pre><pre id="footer">
The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.4.9</i>. (GOOS=linux GOARCH=amd64)</pre>