<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>References: go/types.object.name</title>
<link href="../../css/light-v0.4.9.css" rel="stylesheet">
<script src="../../jvs/golds-v0.4.9.js"></script>
<body onload="onPageLoad()"><div>

<pre><code><span style="font-size:x-large;"><b><a href="../../pkg/go/types.html">go/types</a>.<a href="../../src/go/types/object.go.html#line-82">object</a>.<a href="../../src/go/types/object.go.html#line-86">name</a></b></span><span style="font-size: large;"><i> (field)</i></span>

<span class="title">78 uses</span>

	go/types (current package)
		<a href="../../src/go/types/builtins.go.html#line-865">builtins.go#L865</a>: 		tpar := NewTypeName(token.NoPos, check.pkg, tp.obj.<b>name</b>, nil)
		<a href="../../src/go/types/call.go.html#line-337">call.go#L337</a>: 					vars = append(vars, NewParam(last.pos, last.pkg, last.<b>name</b>, typ))
		<a href="../../src/go/types/call.go.html#line-506" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-506">#L506</a>: 				if pkg.cgo &amp;&amp; strings.HasPrefix(exp.<b>name</b>, "_Cvar_") {
		<a href="../../src/go/types/call.go.html#line-512" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-512">#L512</a>: 				if pkg.cgo &amp;&amp; strings.HasPrefix(exp.<b>name</b>, "_Cmacro_") {
		<a href="../../src/go/types/call.go.html#line-623" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-623">#L623</a>: 		if len(params) &gt; 0 &amp;&amp; params[0].<b>name</b> != "" {
		<a href="../../src/go/types/call.go.html#line-625" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-625">#L625</a>: 			name = sig.recv.<b>name</b>
		<a href="../../src/go/types/call.go.html#line-692" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-692">#L692</a>: 					check.dump("%v: (%s).%v -&gt; %s", e.Pos(), typ, obj.<b>name</b>, m)
		<a href="../../src/go/types/decl.go.html#line-727">decl.go#L727</a>: 			assert(m.<b>name</b> != "_")
		<a href="../../src/go/types/decl.go.html#line-736" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-736">#L736</a>: 		assert(m.<b>name</b> != "_")
		<a href="../../src/go/types/decl.go.html#line-738" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-738">#L738</a>: 			check.errorf(m, _DuplicateMethod, "method %s already declared for %s", m.<b>name</b>, obj)
		<a href="../../src/go/types/decl.go.html#line-755" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-755">#L755</a>: 			assert(m.<b>name</b> != "_")
		<a href="../../src/go/types/decl.go.html#line-762" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-762">#L762</a>: 			if fld.<b>name</b> != "_" {
		<a href="../../src/go/types/decl.go.html#line-770" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-770">#L770</a>: 					check.errorf(alt, _DuplicateFieldAndMethod, "field and method with the same name %s", fld.<b>name</b>)
		<a href="../../src/go/types/decl.go.html#line-807" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-807">#L807</a>: 			check.funcBody(decl, obj.<b>name</b>, sig, fdecl.Body, nil)
		<a href="../../src/go/types/expr.go.html#line-1415">expr.go#L1415</a>: 							"implicit assignment to unexported field %s in %s literal", fld.<b>name</b>, typ)
		<a href="../../src/go/types/infer.go.html#line-326">infer.go#L326</a>: 	check.errorf(posn, _CannotInferTypeArgs, "cannot infer %s (%v)", tpar.obj.<b>name</b>, tpar.obj.pos)
		<a href="../../src/go/types/infer.go.html#line-339" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-339">#L339</a>: 		return list[0].obj.<b>name</b>
		<a href="../../src/go/types/infer.go.html#line-341" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-341">#L341</a>: 		return list[0].obj.<b>name</b> + " and " + list[1].obj.<b>name</b>
		<a href="../../src/go/types/infer.go.html#line-350" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-350">#L350</a>: 		b.WriteString(tname.obj.<b>name</b>)
		<a href="../../src/go/types/infer.go.html#line-353" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-353">#L353</a>: 	b.WriteString(list[n-1].obj.<b>name</b>)
		<a href="../../src/go/types/instantiate.go.html#line-79">instantiate.go#L79</a>: 		tname := NewTypeName(pos, orig.obj.pkg, orig.obj.<b>name</b>, nil)
		<a href="../../src/go/types/labels.go.html#line-42">labels.go#L42</a>: 			check.softErrorf(lbl, _UnusedLabel, "label %s declared but not used", lbl.<b>name</b>)
		<a href="../../src/go/types/lookup.go.html#line-297">lookup.go#L297</a>: 	return m, alt != nil &amp;&amp; alt.<b>name</b> == m.<b>name</b> // alt != nil implies m != nil
		<a href="../../src/go/types/lookup.go.html#line-317" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-317">#L317</a>: 			_, f := tset.LookupMethod(m.pkg, m.<b>name</b>, false)
		<a href="../../src/go/types/lookup.go.html#line-337" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-337">#L337</a>: 		obj, _, _ := lookupFieldOrMethod(V, false, m.pkg, m.<b>name</b>, false)
		<a href="../../src/go/types/lookup.go.html#line-343" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-343">#L343</a>: 			obj, _, _ = lookupFieldOrMethod(NewPointer(V), false, m.pkg, m.<b>name</b>, false)
		<a href="../../src/go/types/lookup.go.html#line-345" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-345">#L345</a>: 				obj, _, _ = lookupFieldOrMethod(V, false, m.pkg, m.<b>name</b>, true /* fold case */)
		<a href="../../src/go/types/lookup.go.html#line-423" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-423">#L423</a>: 	buf := bytes.NewBufferString(f.<b>name</b>)
		<a href="../../src/go/types/lookup.go.html#line-514" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-514">#L514</a>: 			if (m.<b>name</b> == name || foldCase &amp;&amp; strings.EqualFold(m.<b>name</b>, name)) &amp;&amp; m.sameId(pkg, m.<b>name</b>) {
		<a href="../../src/go/types/methodlist.go.html#line-44">methodlist.go#L44</a>: 	if i, _ := lookupMethod(l.methods, m.pkg, m.<b>name</b>, false); i &lt; 0 {
		<a href="../../src/go/types/named.go.html#line-196">named.go#L196</a>: 	return NewFunc(origm.pos, origm.pkg, origm.<b>name</b>, sig)
		<a href="../../src/go/types/object.go.html#line-86">object.go#L86</a>: 	<b>name</b>      string
		<a href="../../src/go/types/object.go.html#line-136" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-136">#L136</a>: func (obj *object) Name() string { return obj.<b>name</b> }
		<a href="../../src/go/types/object.go.html#line-144" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-144">#L144</a>: func (obj *object) Exported() bool { return token.IsExported(obj.<b>name</b>) }
		<a href="../../src/go/types/object.go.html#line-147" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-147">#L147</a>: func (obj *object) Id() string { return Id(obj.pkg, obj.<b>name</b>) }
		<a href="../../src/go/types/object.go.html#line-165" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-165">#L165</a>: 	if name != obj.<b>name</b> {
		<a href="../../src/go/types/object.go.html#line-269" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-269">#L269</a>: 		return obj.pkg != nil || t.name != obj.<b>name</b> || t == universeByte || t == universeRune
		<a href="../../src/go/types/object.go.html#line-379" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-379">#L379</a>: 	return &amp;Label{object{pos: pos, pkg: pkg, <b>name</b>: name, typ: Typ[Invalid], color_: black}, false}
		<a href="../../src/go/types/object.go.html#line-390" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-390">#L390</a>: 	return &amp;Builtin{object{<b>name</b>: predeclaredFuncs[id].name, typ: Typ[Invalid], color_: black}, id}
		<a href="../../src/go/types/object.go.html#line-405" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-405">#L405</a>: 		if path := obj.imported.path; path != "" &amp;&amp; path != obj.<b>name</b> {
		<a href="../../src/go/types/object.go.html#line-550" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-550">#L550</a>: 	buf.WriteString(f.<b>name</b>)
		<a href="../../src/go/types/predicates.go.html#line-218">predicates.go#L218</a>: 						!f.sameId(g.pkg, g.<b>name</b>) ||
		<a href="../../src/go/types/resolver.go.html#line-686">resolver.go#L686</a>: 		if !obj.used &amp;&amp; obj.<b>name</b> != "_" {
		<a href="../../src/go/types/resolver.go.html#line-704" class="path-duplicate">resolver.go</a><a href="../../src/go/types/resolver.go.html#line-704">#L704</a>: 	if obj.<b>name</b> == "" || obj.<b>name</b> == "." || obj.<b>name</b> == elem {
		<a href="../../src/go/types/resolver.go.html#line-707" class="path-duplicate">resolver.go</a><a href="../../src/go/types/resolver.go.html#line-707">#L707</a>: 		check.softErrorf(obj, _UnusedImport, "%q imported but not used as %s", path, obj.<b>name</b>)
		<a href="../../src/go/types/stmt.go.html#line-73">stmt.go#L73</a>: 		check.softErrorf(v, _UnusedVar, "%s declared but not used", v.<b>name</b>)
		<a href="../../src/go/types/stmt.go.html#line-509" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-509">#L509</a>: 		if len(s.Results) == 0 &amp;&amp; res.Len() &gt; 0 &amp;&amp; res.vars[0].<b>name</b> != "" {
		<a href="../../src/go/types/stmt.go.html#line-514" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-514">#L514</a>: 				if alt := check.lookup(obj.<b>name</b>); alt != nil &amp;&amp; alt != obj {
		<a href="../../src/go/types/stmt.go.html#line-515" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-515">#L515</a>: 					check.errorf(s, _OutOfScopeResult, "result parameter %s not in scope at return", obj.<b>name</b>)
		<a href="../../src/go/types/struct.go.html#line-29">struct.go#L29</a>: 		if f.<b>name</b> != "_" &amp;&amp; fset.insert(f) != nil {
		<a href="../../src/go/types/subst.go.html#line-418">subst.go#L418</a>: 			out[i] = NewFunc(method.pos, method.pkg, method.<b>name</b>, &amp;newsig)
		<a href="../../src/go/types/typeset.go.html#line-229">typeset.go#L229</a>: 				panic(fmt.Sprintf("%v: duplicate method %s", m.pos, m.<b>name</b>))
		<a href="../../src/go/types/typeset.go.html#line-232" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-232">#L232</a>: 			check.errorf(atPos(pos), _DuplicateDecl, "duplicate method %s", m.<b>name</b>)
		<a href="../../src/go/types/typeset.go.html#line-233" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-233">#L233</a>: 			check.errorf(atPos(mpos[other.(*Func)]), _DuplicateDecl, "\tother declaration of %s", m.<b>name</b>) // secondary error, \t indented
		<a href="../../src/go/types/typeset.go.html#line-248" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-248">#L248</a>: 					check.errorf(atPos(pos), _DuplicateDecl, "duplicate method %s", m.<b>name</b>)
		<a href="../../src/go/types/typeset.go.html#line-249" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-249">#L249</a>: 					check.errorf(atPos(mpos[other.(*Func)]), _DuplicateDecl, "\tother declaration of %s", m.<b>name</b>) // secondary error, \t indented
		<a href="../../src/go/types/typeset.go.html#line-322" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-322">#L322</a>: 			panic(fmt.Sprintf("%v: duplicate method %s", m.pos, m.<b>name</b>))
		<a href="../../src/go/types/typestring.go.html#line-162">typestring.go#L162</a>: 				w.string(f.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-237" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-237">#L237</a>: 				w.string(m.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-308" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-308">#L308</a>: 			w.string(t.obj.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-330" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-330">#L330</a>: 		w.string(m.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-401" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-401">#L401</a>: 	w.string(obj.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-412" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-412">#L412</a>: 			if w.ctxt == nil &amp;&amp; v.<b>name</b> != "" {
		<a href="../../src/go/types/typestring.go.html#line-413" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-413">#L413</a>: 				w.string(v.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-460" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-460">#L460</a>: 	if n == 1 &amp;&amp; (w.ctxt != nil || sig.results.vars[0].<b>name</b> == "") {
		<a href="../../src/go/types/typexpr.go.html#line-78">typexpr.go#L78</a>: 		check.errorf(e, _InvalidPkgUse, "use of package %s not in selector", obj.<b>name</b>)
		<a href="../../src/go/types/typexpr.go.html#line-100" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-100">#L100</a>: 			check.errorf(e, _InvalidDeclCycle, "invalid use of type alias %s in recursive type (see issue #50729)", obj.<b>name</b>)
		<a href="../../src/go/types/typexpr.go.html#line-441" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-441">#L441</a>: 		tname := NewTypeName(ix.Pos(), orig.obj.pkg, orig.obj.<b>name</b>, nil)
		<a href="../../src/go/types/unify.go.html#line-430">unify.go#L430</a>: 						!f.sameId(g.pkg, g.<b>name</b>) ||
		<a href="../../src/go/types/unify.go.html#line-558" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-558">#L558</a>: 			if x.obj.pkg == y.obj.pkg &amp;&amp; x.obj.<b>name</b> == y.obj.<b>name</b> {
		<a href="../../src/go/types/universe.go.html#line-139">universe.go#L139</a>: 	def(&amp;Nil{object{<b>name</b>: "nil", typ: Typ[UntypedNil], color_: black}})
</code></pre><pre id="footer">
The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.4.9</i>. (GOOS=linux GOARCH=amd64)</pre>